'use strict';

const repositoryWatcher = require('repository-watcher');
const installFileModifiedWatcher = {};
const logger = require('dachshund-logger').getLogger(__filename);
const isInInstallFolderRegex = /^(\/apps\/[^\/]+\/install)\/.*/;
const isInInstallFolderPropertiesRegex = /^(\/apps\/[^\/]+\/install)\/\.properties/;
const repositoryManager = require('repository-manager');
const mkdirp = require('mkdirp');
const fs = require('fs');
const path = require('path');
const Q = require('q');
const rmdir = require('rimraf');

installFileModifiedWatcher.test = function (filePath) {
    return isInInstallFolderRegex.test(filePath) && !isInInstallFolderPropertiesRegex.test(filePath) && !filePath.contains('bower_components');
};

const handleCopyFile = function (filePath) {
    let applicationInstallPath = isInInstallFolderRegex.exec(filePath)[1];
    let filePathIsDirectory = false;
    Q.nfcall(fs.lstat, '.' + filePath).then(function (fileStat) {
        filePathIsDirectory = fileStat.isDirectory();
        return repositoryManager.resolve(applicationInstallPath);
    }).then(function (applicationInstallResource) {
        if (applicationInstallResource.properties.installAlways === true || applicationInstallResource.properties.alreadyInstalled === false) {
            let destinationPath = filePath.substring(applicationInstallPath.length);
            if (filePathIsDirectory) {
                mkdirp('.' + destinationPath, function (error) {
                    if (error) {
                        logger.error('Couldn\'t create folder: ' + destinationPath + ' because of ' + error.toString());
                    }
                    else {
                        logger.trace("Created folder: " + destinationPath);
                    }
                });
            }
            else {
                let destinationFolder = destinationPath.lastSubstringBefore('/');
                if (destinationFolder.length === 0) {
                    fs.createReadStream('.' + filePath).pipe(fs.createWriteStream('.' + destinationPath));
                }
                else {
                    mkdirp('.' + destinationFolder, function (error) {
                        if (error) {
                            logger.error('Couldn\'t create folder: ' + destinationPath + ' because of ' + err.toString());
                        }
                        else {
                            fs.createReadStream('.' + filePath).pipe(fs.createWriteStream('.' + destinationPath));
                            logger.trace("Copied file: " + filePath);
                        }
                    });
                }
            }
        }
    }).fail(function (err) {
        logger.error("Error while execute file modified handler on /apps/<app>/install folder: " + err.toString());
    });
};

const handleDeleteFile = function (filePath) {
    let applicationInstallPath = isInInstallFolderRegex.exec(filePath)[1];
    repositoryManager.resolve(applicationInstallPath).then(function (applicationInstallResource) {
        if (applicationInstallResource.properties.installAlways === true || applicationInstallResource.properties.alreadyInstalled === false) {
            let destinationPath = filePath.substring(applicationInstallPath.length);
            return Q.nfcall(rmdir, '.' + destinationPath);
        }
    }).then(function(){
        logger.trace("Deleted file: " + filePath);
    }).fail(function (err) {
        logger.error("Error while execute file delete handler on /apps/<app>/install folder: " + err.toString());
    });
};

installFileModifiedWatcher.handle = function (filePath, fileDeleted) {
    if (fileDeleted) {
        handleDeleteFile(filePath);
    } else {
        handleCopyFile(filePath);
    }
};

repositoryWatcher.addWatcher(installFileModifiedWatcher);