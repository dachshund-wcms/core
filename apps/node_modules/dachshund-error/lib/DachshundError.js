class DachshundError extends Error {

	/**
	 * Extended version of the standard {@link Error} to store more information of an error
	 *
	 * @param {string} [message] - Describing error message
	 * @param {number} id - ID of the error, to distinguish errors by their identifier
	 * @param {DachshundError|Error} nestedError - nested error which is encapbsulated in this error
	 *
	 * @example
	 *
	 * someFailingFunction() {
	 *
	 *
	 * 	let originError = new Error('The dog has eaten all the food');
	 *
	 * 	// Can be encapsulated und thrown as an exception
	 * 	throw new DachshundError('No dog food left', 404, originError);
	 *
	 * }
	 */
	constructor(message, id, nestedError) {
		super(message);
		this.message = "undefined error";
		this.id = -1;
		this.nestedError = null;

		if (typeof(message) === 'string' || message instanceof String)
		{
			this.message = message;
			Error.call(this, message);
		}
		else if (!isNaN(message))
		{
			this.id = message;
		}
		else if (message instanceof Error)
		{
			this.nestedError = message;
		}

		if (!isNaN(id))
		{
			this.id = id;
		}
		else if (id instanceof Error)
		{
			this.nestedError = id;
		}

		if (nestedError instanceof Error)
		{
			this.nestedError = nestedError;
		}
	}

	toString() {
		let errorMessage = "";

		if (typeof(this.message) === 'string' || this.message instanceof String)
		{
			errorMessage += this.message;
		}

		if (this.nestedError !== undefined && this.nestedError !== null)
		{
			errorMessage += "\n\t" + this.nestedError.toString();
		}

		return errorMessage;
	};

	get stack() {
		return this.nestedError !== undefined ? this.nestedError.stack : "\t ... unkndown ...";
	}

}

module.exports = DachshundError;