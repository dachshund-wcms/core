class DachshundError extends Error {

	/**
	 * Extended version of the standard {@link Error} to store more information of an error
	 *
	 * @param {string} [message] - Describing error message
	 * @param {number} id - ID of the error, to distinguish errors by their identifier
	 * @param {DachshundError|Error} nestedError - nested error which is encapbsulated in this error
	 *
	 * @example
	 *
	 * //Init promise
	 * const Q = require('q');
	 *
	 * someFailingFunction() {
	 *
	 * 	let deferred = Q.defer();
	 *
	 * 	let originError = new Error('The dog has eaten all the food');
	 *
	 * 	// Can be returned by a promise
	 * 	deferred.reject(new DachshundError('No dog food left', 404, originError));
	 *
	 * 	// or can be thrown in an exception
	 * 	throw(new DachshundError('No dog food left', 404, originError));
	 *
	 *	return deferred.promise;
	 *
	 * }
	 */
	constructor(message, id, nestedError) {
		this.message = "undefined error";
		this.id = -1;
		this.nestedError = null;

		if (typeof(message) == 'string' || message instanceof String)
		{
			this.message = message;
			Error.call(this, message);
		}
		else if (!isNaN(message))
		{
			this.id = message;
		}
		else if (message instanceof Error)
		{
			this.nestedError = message;
		}

		if (!isNaN(id))
		{
			this.id = id;
		}
		else if (id instanceof Error)
		{
			this.nestedError = id;
		}

		if (nestedError instanceof Error)
		{
			this.nestedError = nestedError;
		}
	}

	toString() {
		var errorMessage = "";

		if (typeof(this.message) == 'string' || this.message instanceof String)
		{
			errorMessage += this.message;
		}

		if (this.nestedError != undefined && this.nestedError != null)
		{
			errorMessage += "\n\t" + this.nestedError.toString();
		}

		return errorMessage;
	};

	get stack() {
		return this.nestedError != undefined ? this.nestedError.stack : "\t ... unkndown ...";
	}

}

module.exports = DachshundError;