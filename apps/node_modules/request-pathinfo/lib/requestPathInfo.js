'use strict';

require("string-utils");
const http = require('http');
const url = require("url");
const Cookies = require("cookies");
const logger = require('dachshund-logger').getLogger(__filename);


class RequestPathInfo {

	/**
	 * Extracts information from the HTTP request to provide them in the further process on resolving resources or processing components
	 * @param {ClientRequest|string|RequestPathInfo} request - In case the {@link ClientRequest} or string is passed, the information will be extracted and populated into the class members. In case a {@link RequestPathInfo} is passed, the reference will be cloned into this new referenced object
	 */
	constructor(request) {
		/**
		 * Hostname (e.g. 'www.foo.bar')
		 * @type {string}
		 */
		this.host = null;

		/**
		 * TCP/IP Port Number (e.g. '80' for unencrypted requests, '443' for encrypted requests)
		 * @type {number}
		 */
		this.port = null;

		/**
		 * Method which is used in the request (e.g. GET, POST, HEAD, PUT, DELETE)
		 * @type {string}
		 */
		this.method = null;

		/**
		 * Full qualified URI (e.g. 'https://www.foo.bar/path/to/my/content.selector.html/suffix?foo=bar&bar=foo')
		 * @type {string}
		 */
		this.url = null;

		/**
		 * Complete application path of the url including path, selector and extension (e.g. '/path/tp/my/content.selector.html')
		 * @type {string}
		 */
		this.completePath = null;

		/**
		 * Whole the application path which include everything behind the hostname up to the first dot (e.g. '/path/to/my/content')
		 * @type {string}
		 */
		this.componentPath = null;

		/**
		 * Selector string of the URI. Contains everything of the complete path between the first and the last dot of the completePath
		 * @type {string}
		 */
		this.selector = null;

		/**
		 * Contains the file extension which is located behind the last dot and before the suffix or request parameters
		 * @type {string}
		 */
		this.extension = null;

		/**
		 * The suffix is defined behind the extension and starts with a slash (e.g. '/path/tp/my/content.html/suffix/path' --> '/suffix/path')
		 * @type {string}
		 */
		this.suffix = null;

		/**
		 * A map of all cookies which are passed on with the request
		 * @type {Object.<string,string>}
		 */
		this.cookies = null;

		/**
		 * A map of all parameters which are defined in the URI behinde the questionmark
		 * @type {Object.<string,string>}
		 */
		this.parameters = {};

		//Init Requesr Information
		this.init(request);
	}

	// Initiates the class and extracts the information from the given HTTP request parameter
	init(request) {
		if (request instanceof http.IncomingMessage)
		{
			extractRequestInfo(this, request);
			extractApplicationPath(this, request.url);
		}
		else if (typeof (request) == 'string' || request instanceof String)
		{
			extractApplicationPath(this, request);
		}
		else if (request instanceof RequestPathInfo)
		{
			request.clone(this);
		}
		else if (request != undefined && request != null)
		{
			logger.debug("Cannot read data for [RequestPathInfo] from [" + typeof (request) + "]");
		}
	}

	/**
	 * Creates a clone of the current requestPathInfo. This method is used to modify a cloned reference without affecting the origin
	 * @param {RequestPathInfo|Object} [clonedPathInfo] will be used as reference for the clone
	 * @returns {RequestPathInfo} with the cloned members from this reference
	 */
	clone(clonedPathInfo) {
		clonedPathInfo = clonedPathInfo || new RequestPathInfo();

		for (let key in this)
		{
			clonedPathInfo[key] = this[key];
		}

		return clonedPathInfo;
	}

	/**
	 * @return a pretty print json object with the members of this class
	 */
	toString() {
		let objectData = {
			"host": this.host,
			"port": this.port,
			"method": this.method,
			"url": this.url,
			"completePath": this.completePath,
			"componentPath": this.componentPath,
			"selector": this.selector,
			"extension": this.extension,
			"suffix": this.suffix,
			"parameters": this.parameters
		};
		return JSON.stringify(objectData, null, 2);
	}
}

module.exports = RequestPathInfo;

const extractRequestInfo = function(pathInfo, request) {
	pathInfo.cookies = new Cookies(request);

	try
	{
		pathInfo.host = request.headers.host.substringBefore(":");
		pathInfo.port = request.headers.host.substringAfter(":");
		pathInfo.method = request.method;
	} catch (err)
	{
		logger.error("Error while extracting path info: " + err);
	}
};

const extractApplicationPath = function(pathInfo, requestURL) {

	try
	{
		let parsedUrl = url.parse(requestURL, true);

		pathInfo.url = requestURL;
		pathInfo.completePath = decodeURIComponent(requestURL.substringBefore("?") + "");
		pathInfo.componentPath = pathInfo.completePath.match(/^(\/.?[^\/.]*)*/)[0] + "";

		let urlAfterResource = pathInfo.completePath.lastSubstringAfter(".");
		pathInfo.parameters = parsedUrl.query;
		pathInfo.extension = urlAfterResource;
		let extensionHasSuffix = urlAfterResource.indexOf("/") != -1;
		if (extensionHasSuffix)
		{
			pathInfo.suffix = "/" + urlAfterResource.substringAfter("/");
			pathInfo.extension = urlAfterResource.substr(0, urlAfterResource.length - pathInfo.suffix.length);
			pathInfo.completePath = pathInfo.completePath.substr(0, pathInfo.completePath.length - pathInfo.suffix.length);
		}
		let extensionHasSelector = ((pathInfo.completePath.length - 1) > (pathInfo.componentPath.length + pathInfo.extension.length))
		if (extensionHasSelector)
		{
			pathInfo.selector = pathInfo.completePath.substringBetween(pathInfo.componentPath + ".", "." + pathInfo.extension);
		}
	} catch (err)
	{
		logger.error("Error while processing application path: " + err.toString());
	}
};