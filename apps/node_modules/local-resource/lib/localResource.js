'use strict';

const Resource = require('resource');
const ResourceTypes = require('resource-types');
const fs = require('fs-es6-promise');
const assert = require('assert');
const nodeProperties = require('./nodeProperties.js');
const nodeAuthorization = require("./nodeAuthorization.js");
const repositoryManager = require('repository-manager');
const asyncUtils = require('async-utils');

/**
 * The local resource represents a resource which is held in the local file systen. The physical element of a resource
 * is a folder in the file system. The files '.properties.json' and 'auth.json' contain the properties and authorization
 * information of the resource. It provides access to the child resources through the held sub-folders. The parent
 * resource is the parent folder. The files in this folders can be access and modified as well.
 * @class
 * @extends Resource
 */
class LocalResource extends Resource {

	/**
	 * @inheritDoc
	 */
	async getFiles(includeHiddenFiles) {
		if (includeHiddenFiles === undefined)
		{
			includeHiddenFiles = false;
		}

		let resourceFiles = this._resourceFiles;

		if (resourceFiles === null && this.type === ResourceTypes.RESOURCE)
		{
			resourceFiles = [];
			let path = this.path;
			let files = await fs.readdir("." + path);
			await asyncUtils.forEachSequential(files, async file => {
				let fileStat = await fs.stat("." + path + "/" + file);
				if (fileStat.isFile() && (includeHiddenFiles || !file.startsWith(".")))
				{
					resourceFiles.push(file);
				}
			});

			this._resourceFiles = resourceFiles;
		}

		return resourceFiles;
	}

	/**
	 * @inheritDoc
	 */
	async fileExists(filename) {
		const includeHiddenFiles = true;
		return (await this.getFiles(includeHiddenFiles)).indexOf(filename) !== -1;
	}

	/**
	 * @inheritDoc
	 */
	async deleteFile(filename) {
		let fileExists = await this.fileExists(filename);
		if (fileExists)
		{
			let filePath = "." + self.path + "/" + filename;
			await fs.unlink(filePath);
			self._resourceFiles = null;
		}
		else
		{
			throw new Error(`File [${filename}] doesn't exist.`);
		}
	}

	/**
	 * @inheritDoc
	 */
	async deleteAllFiles(includeHiddenFiles) {
		let self = this;
		let includeHidden = includeHiddenFiles || false;

		let fileList = await this.getFiles(includeHidden);

		await asyncUtils.forEachParallel(fileList, file => {
			return self.deleteFile(file);
		});
	}

	/**
	 * @inheritDoc
	 */
	addFile(sourceReadStream, filename) {
		return new Promise((resolve, reject) => {
			let destinationPath = "." + this.path + "/" + filename;
			let destinationFile = fs.createWriteStream(destinationPath);
			destinationFile.on('finish', resolve).on('error', reject);
			sourceReadStream.pipe(destinationFile);
		});
	}

	/**
	 * @inheritDoc
	 */
	async loadScript(scriptName) {
		let fileExists = await this.fileExists(scriptName);

		if (!fileExists)
		{
			throw new Error(`Script [${this.path}/${scriptName}] doesn't exist.`);
		}

		return require(process.cwd() + this.path + "/" + scriptName);
	}

	/**
	 * @inheritDoc
	 */
	async getChilds(includeHidden) {
		let resourceChilds = this._resourceChilds || [];
		includeHidden = includeHidden || false;

		if (this.type === ResourceTypes.RESOURCE && this._resourceChilds === undefined)
		{
			resourceChilds = [];
			let path = this.path;
			let files = await fs.readdir("." + path);
			await asyncUtils.forEachParallel(files, async file => {
				let fileStat = await fs.stat('.' + path + '/' + file);
				if (fileStat.isDirectory() && (includeHidden || !file.startsWith(".")))
				{
					resourceChilds.push(file);
				}
			});

			this._resourceChilds = resourceChilds;
		}

		return resourceChilds;
	}

	/**
	 * @inheritDoc
	 */
	async getChildResources(includeHidden) {
		let self = this;
		let childNames = await this.getChilds(includeHidden);
		if (childNames.length === 0)
		{
			return [];
		}

		return await asyncUtils.forEachParallel(childNames, childName => {
			let childResourcePath = self.path + "/" + childName;
			return repositoryManager.resolve(childResourcePath);
		});

	}

	/**
	 * @inheritDoc
	 */
	async getParentResource() {
		let parentPath = this.path.lastSubstringBefore("/");

		if (parentPath.length > 0)
		{
			return await repositoryManager.resolve(parentPath);
		}

		return null;
	}

	/**
	 * @inheritDoc
	 */
	async getAbsoluteParentResource(depth) {
		assert(!isNaN(depth), "It is expected that the paramater [depth] is a number.");
		assert(depth >= 0, "It is expected that the parameter [depth] is greater or equal than zero.");

		depth += 1;
		if (this.depth < depth)
		{
			throw new Error("The request depth [" + depth + "] can't be resolved from [" + this.path + "]");
		}
		else if (this.depth === depth)
		{
			return this;
		}
		else
		{
			let sourcePathFragments = this.path.split("/");
			let destinationPathFragments = sourcePathFragments.slice(0, depth);
			let destinationPath = destinationPathFragments.join("/");
			return await repositoryManager.resolve(destinationPath);
		}
	}

	/**
	 * @inheritDoc
	 */
	async getHiddenResourceChilds() {
		let resourceChilds = this._resourceChilds;

		if (resourceChilds === null && this.type === resourceTypes.RESOURCE)
		{
			resourceChilds = [];
			let path = this.path;
			let files = await fs.readdir("." + path);
			files.forEach(async function(file) {
				let filePath = "." + path + "/" + file;
				let fileStat = await fs.stat(filePath);
				if (fileStat.isDirectory() && file.startsWith("."))
				{
					resourceChilds.push(file);
				}
			});
			this._resourceChilds = resourceChilds;
		}

		return resourceChilds;
	}

	/**
	 * @inheritDoc
	 */
	async loadProperties() {
		this.properties = await nodeProperties.load(this.path);
		return this.properties;
	}

	/**
	 * @inheritDoc
	 */
	async saveProperties() {
		this.properties.id = this.properties.id || this.id;
		await nodeProperties.save(this.path, this.properties);
		this.properties.id = undefined;
		return this;
	}

	/**
	 * @inheritDoc
	 */
	async loadAuthorization() {
		this.auth = await nodeAuthorization.load(this.path);
		return this;
	}

	/**
	 * @inheritDoc
	 */
	async saveAuthorization() {
		await nodeAuthorization.save(this.path, this.auth);
		return this;
	}

}

module.exports = LocalResource;