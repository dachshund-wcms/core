'use strict';

const Resource = require('resource');
const ResourceTypes = require('resource-types');
const fs = require('fs');
const assert = require('assert');
const nodeProperties = require('./nodeProperties.js');
const nodeAuthorization = require("./nodeAuthorization.js");
const Q = require('q');
const repositoryManager = require('repository-manager');

/**
 * The local resource represents a resource which is held in the local file systen. The physical element of a resource
 * is a folder in the file system. The files '.properties.json' and 'auth.json' contain the properties and authorization
 * information of the resource. It provides access to the child resources through the held sub-folders. The parent
 * resource is the parent folder. The files in this folders can be access and modified as well.
 * @class
 * @extends Resource
 */
class LocalResource extends Resource {

	/**
	 * @inheritDoc
	 */
	getFiles(includeHiddenFiles) {
		let deferred = Q.defer();
		if (includeHiddenFiles == undefined)
		{
			includeHiddenFiles == false;
		}

		let resourceFiles = this._resourceFiles;

		if (resourceFiles == null && this.type == ResourceTypes.RESOURCE)
		{
			resourceFiles = [];
			let path = this.path;
			fs.readdirSync("." + path).forEach(function(file) {
				if (fs.statSync("." + path + "/" + file).isFile() && (includeHiddenFiles || !file.startsWith(".")))
				{
					resourceFiles.push(file);
				}
			});
			this._resourceFiles = resourceFiles;
		}

		deferred.resolve(resourceFiles);
		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	fileExists(filename) {
		let deferred = Q.defer();

		const includeHiddenFiles = true;
		this.getFiles(includeHiddenFiles).then(function(files) {
			deferred.resolve(files.indexOf(filename) != -1);
		}).fail(deferred.reject);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	deleteFile(filename) {
		let self = this;
		let deferred = Q.defer();

		this.fileExists(filename).then(function(fileExists) {
			if (fileExists)
			{
				let filePath = "." + self.path + "/" + filename;
				Q.nfcall(fs.unlink, filePath).then(function() {
					self._resourceFiles = null;
					deferred.resolve();
				}).fail(deferred.reject);
			}
			else
			{
				deferred.reject(new Error("File [" + filename + "] doesn't exist."));
			}
		}).fail(deferred.reject);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	deleteAllFiles(includeHiddenFiles) {
		let self = this;
		let deferred = Q.defer();

		let includeHidden = includeHiddenFiles || false;

		this.getFiles(includeHidden).then(function(fileList) {

			let deleteFilesPromises = [];
			fileList.forEach(function(fileName) {
				deleteFilesPromises.push(self.deleteFile(fileName));
			});

			Q.allSettled(deleteFilesPromises).then(function() {
				deferred.resolve(self);
			}).fail(deferred.reject);

		}).fail(deferred.reject);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	addFile(sourceReadStream, filename) {
		let deferred = Q.defer();

		let destinationPath = "." + this.path + "/" + filename;
		let destinationFile = fs.createWriteStream(destinationPath);
		destinationFile.on('finish', deferred.resolve).on('error', deferred.reject);
		sourceReadStream.pipe(destinationFile);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	loadScript(scriptName) {
		let deferred = Q.defer();
		let self = this;

		this.fileExists(scriptName).then(function(fileExists) {
			if (!fileExists)
			{
				deferred.reject(new Error("Script '" + self.path + "/" + scriptName + "' doesn't exist."));
			}
			else
			{
				try
				{
					let resolvedScript = require(process.cwd() + self.path + "/" + scriptName);
					deferred.resolve(resolvedScript);
				} catch (err)
				{
					deferred.reject(err);
				}
			}
		}).fail(deferred.reject);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	getChilds(includeHidden) {
		let deferred = Q.defer();
		let resourceChilds = this._resourceChilds || [];
		includeHidden = includeHidden || false;

		if (this.type == ResourceTypes.RESOURCE)
		{
			resourceChilds = [];
			let path = this.path;
			fs.readdirSync("." + path).forEach(function(file) {
				if (fs.statSync("." + path + "/" + file).isDirectory() && (includeHidden || !file.startsWith(".")))
				{
					resourceChilds.push(file);
				}
			});

			this._resourceChilds = resourceChilds;
		}

		deferred.resolve(resourceChilds);
		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	getChildResources(includeHidden) {
		let deferred = Q.defer();
		let self = this;
		this.getChilds(includeHidden).then(function(childNames) {

			if (childNames.length == 0)
			{
				deferred.resolve([]);
				if (cb instanceof Function)
				{
					cb([]);
				}
			}

			let childResourcePromises = [];
			childNames.forEach(function(childName) {
				let childResourcePath = self.path + "/" + childName;
				childResourcePromises.push(repositoryManager.resolve(childResourcePath));
			});
			Q.all(childResourcePromises).then(function(childResources) {
				deferred.resolve(childResources);
			}).fail(deferred.reject)
		});
		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	getParentResource() {
		let deferred = Q.defer();
		let parentPath = this.path.lastSubstringBefore("/");

		if (parentPath.length > 0)
		{
			repositoryManager.resolve(parentPath).then(function(parentResource) {
				deferred.resolve(parentResource);
			}).fail(deferred.reject);
		}
		else
		{
			deferred.resolve(null);
		}
		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	getAbsoluteParentResource(depth) {
		assert(!isNaN(depth), "It is expected that the paramater [depth] is a number.");
		assert(depth >= 0, "It is expected that the parameter [depth] is greater or equal than zero.");

		let deferred = Q.defer();

		depth += 1;
		if (this.depth < depth)
		{
			deferred.reject(new Error("The request depth [" + depth + "] can't be resolved from [" + this.path + "]"));
		}
		else if (this.depth == depth)
		{
			deferred.resolve(this);
		}
		else
		{
			let sourcePathFragments = this.path.split("/");
			let destinationPathFragments = sourcePathFragments.slice(0, depth);
			let destinationPath = destinationPathFragments.join("/");
			repositoryManager.resolve(destinationPath).then(deferred.resolve).fail(deferred.reject);
		}

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	getHiddenResourceChilds() {
		let deferred = Q.defer();
		let resourceChilds = this._resourceChilds;

		if (resourceChilds == null && this.type == resourceTypes.RESOURCE)
		{
			resourceChilds = [];
			let path = this.path;
			fs.readdirSync("." + path).forEach(function(file) {
				if (fs.statSync("." + path + "/" + file).isDirectory() && file.startsWith("."))
				{
					resourceChilds.push(file);
				}
			});
			this._resourceChilds = resourceChilds;
		}
		deferred.resolve(resourceChilds);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	loadProperties() {
		let deferred = Q.defer();

		this.properties = nodeProperties.load(this.path);

		deferred.resolve(this);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	saveProperties() {
		let self = this;
		let deferred = Q.defer();

		this.properties.id = this.properties.id || this.id;
		nodeProperties.save(this.path, this.properties);
		this.properties.id = undefined;
		deferred.resolve(self);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	loadAuthorization() {
		let deferred = Q.defer();

		this.auth = nodeAuthorization.load(this.path);
		deferred.resolve(this);

		return deferred.promise;
	}

	/**
	 * @inheritDoc
	 */
	saveAuthorization() {
		let deferred = Q.defer();
		nodeAuthorization.save(this.path, this.auth);

		deferred.resolve(this);

		return deferred.promise;
	}

}

module.exports = LocalResource;