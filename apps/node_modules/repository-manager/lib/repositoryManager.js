'use strict';

const logger = require('dachshund-logger').getLogger(__filename);
const Resource = require('resource');
const config = require('config');
const assert = require('assert');
const RequestPathInfo = require('request-pathinfo');
const stringUtils = require('string-utils');
const Q = require('q');

const resolvedRepositoryManager = {};

/**
 * Provides full access to the non structured repository to resolve or create a {@link Resource}. This repository manager is stateless and doesn't incorporate the access rights. When you want to do this you have to use the {@link RepositorySession} which is accessible trough the http request at {@link req.session}. The available methods are identical, but the resulting {@link Resource} will incorporate the access rights of the {@link UserSession} which is bound to the repository session.
 *
 * @example
 *
 * // reference repository
 * const repositoryManager = require('repository-manager');
 *
 * // resolve a resource with the repository manager
 * repositoryManager.resolve("/content/path/to/my/resource").then(function(resource){
 *	// do something with the resource
 * }).fail(function(err){
 * 	//do something with the error object
 * });
 *
 * @class
 */
class RepositoryManager {

	/**
	 * Creates a new empty resource which is temporary and isn't persisted in the repository. The {@link Resource.type} of the resolved {@link Resource} will be {@link ResourceTypes.NOT_FOUND}.
	 * @param {RequestPathInfo | string} pathInfo - path to resolve the responsible repository manager to create the empty resource
	 * @returns {promise} resolves with the {@link Resource} requested in the parameter
	 */
	createEmptyResource(pathInfo) {
		return Q(new Resource());
	}

	/**
	 * Creates a new {@link Resource} empty resource and saves it in the repository. The {@link Resource.type} of the resolved {@link Resource} will be {@link ResourceTypes.RESOURCE}.
	 * @param {string} newResourceBasePath - Base path in which the new resource will be created (e.g. '/content/myPage/.content/comments')
	 * @param {string} newResourceName - Name of the new resource
	 * @returns {promise} resolves with the {@link Resource} requested in the parameter and fails in case the resource couldn't be created. This is the case when the base path doesn't exist or the new resource name is occupied
	 */
	createResource(newResourceBasePath, newResourceName) {
		return Q(new Resource());
	}

	/**
	 * Looks up the requested resource in the repository and provides it in the resulting promise
	 * @param {RequestPathInfo | string} pathInfo - path to resolve the requested resource
	 * @returns {promise} resolves with the {@link Resource} which was requested. Depending on the requested resource the following different results are possible:
	 * - In case the resource could be resolved the {@link Resource.type} will be {@link ResourceTypes.RESOURCE}
	 * - In case the resource points to a file the {@link Resource.type} will be {@link ResourceTypes.FILE}
	 * - In case the resource couldn't be found an empty {@link Resource} is resolved which {@link Resource.type} is {@link ResourceTypes.NOT_FOUND}
	 */
	resolve(pathInfo) {
		return Q(new Resource());
	}

	/**
	 * Creates a new empty resource which is temporary and isn't persisted in the repository. The {@link Resource.type} of the resolved {@link Resource} will be {@link ResourceTypes.NOT_FOUND}.
	 * @param {RequestPathInfo | string} pathInfo - path to resolve the responsible repository manager to create the empty resource
	 * @returns {promise} resolves with the {@link Resource} requested in the parameter
	 */
	static createEmptyResource(pathInfo) {
		return resolveRepositoryManager(pathInfo).createEmptyResource(pathInfo);
	}

	/**
	 * Creates a new {@link Resource} empty resource and saves it in the repository. The {@link Resource.type} of the resolved {@link Resource} will be {@link ResourceTypes.RESOURCE}.
	 * @param {string} newResourceBasePath - Base path in which the new resource will be created (e.g. '/content/myPage/.content/comments')
	 * @param {string} newResourceName - Name of the new resource
	 * @returns {promise} resolves with the {@link Resource} requested in the parameter and fails in case the resource couldn't be created. This is the case when the base path doesn't exist or the new resource name is occupied
	 */
	static createResource(newResourceBasePath, newResourceName) {
		return resolveRepositoryManager(newResourceBasePath).createResource(newResourceBasePath, newResourceName);
	}

	/**
	 * Looks up the requested resource in the repository and provides it in the resulting promise
	 * @param {RequestPathInfo | string} pathInfo - path to resolve the requested resource
	 * @returns {promise} resolves with the {@link Resource} which was requested. Depending on the requested resource the following different results are possible:
	 * - In case the resource could be resolved the {@link Resource.type} will be {@link ResourceTypes.RESOURCE}
	 * - In case the resource points to a file the {@link Resource.type} will be {@link ResourceTypes.FILE}
	 * - In case the resource couldn't be found an empty {@link Resource} is resolved which {@link Resource.type} is {@link ResourceTypes.NOT_FOUND}
	 */
	static resolve(pathInfo) {
		return resolveRepositoryManager(pathInfo).resolve(pathInfo);
	}
}

module.exports = RepositoryManager;

const resolveRepositoryManager = function(pathInfo) {

	//Extract the selected resource path from the 'pathInfo' parameter
	assert(pathInfo != undefined, 'The parameter "pathInfo" is not defined.');
	let selectedResourcePath = null;
	if (pathInfo instanceof RequestPathInfo)
	{
		selectedResourcePath = pathInfo.componentPath;
	}
	else if (stringUtils.isNotEmpty(pathInfo))
	{
		selectedResourcePath = pathInfo;
	}
	assert(stringUtils.isNotEmpty(selectedResourcePath), "The resource path to be checked is not defined.");

	//Lookup resource manager which is able to resolve the resource path
	let repositoryManagerPathSelector = config.get('repositoryManager.repositoryManagerPathSelector');
	let selectedRepositoryManager = null;
	for (let repositoryManager of repositoryManagerPathSelector)
	{
		assert(stringUtils.isNotEmpty(repositoryManager.path), "One repository manager from the config 'repositoryManager.repositoryManagerPathSelector' has no path defined.");

		if (repositoryManager.pathRegex == undefined)
		{
			repositoryManager.pathRegex = new RegExp(repositoryManager.path);
		}

		if (repositoryManager.path.match(repositoryManager.pathRegex))
		{
			selectedRepositoryManager = repositoryManager;
			break;
		}
	}
	assert(selectedRepositoryManager != null, 'It wasn\'t possible to find a matching repository manager');

	//Load the selected resource manager and store it on the map 'resolvedRepositoryManager' to create a singleton and
	//reloading on the next access
	if (resolvedRepositoryManager[selectedRepositoryManager.path] == undefined)
	{
		let repositoryManagerModule = require(selectedRepositoryManager.nodeModule);
		resolvedRepositoryManager[selectedRepositoryManager.path] = new repositoryManagerModule();
	}
	let loadedRepositoryManager = resolvedRepositoryManager[selectedRepositoryManager.path];

	return loadedRepositoryManager;
};