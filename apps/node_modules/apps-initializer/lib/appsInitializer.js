'use strict';

require('string-utils');
const repositoryManager = require('repository-manager');
const resourceTypes = require('resource-types');
const APPLICATIONS_BASE_PATH = "/apps";
const NODE_MODULES_PATH_NAME = "node_modules";
const NAME_APPLICATION_INSTALL_FOLDER = "install";
const logger = require('dachshund-logger').getLogger(__filename);
const fs = require('fs-es6-promise');
const appsInitializer = exports;
const cpr = require('cpr');
const bowerComponentsRegex = /\/bower_components/;
const asyncUtils = require('async-utils');
const pathExists = require('path-exists')
// Asynchronous recursive file copy utility - Concurrency limit

appsInitializer.init = async function() {

	let applicationsBaseResource = await repositoryManager.resolve(APPLICATIONS_BASE_PATH);
	let applicationNames = await applicationsBaseResource.getChilds();

	//TODO include as well!!
	// Init the node modules which are stored in the /apps root path
	//promisesInitializedApps.push(initApplicationNodeModules());

	let appsInitialized = await asyncUtils.forEachParallel(applicationNames, async applicationName => {
		if (applicationName !== NODE_MODULES_PATH_NAME)
		{
			return initApplication(applicationName);
		}
	});

	if (appsInitialized.length === 0)
	{
		logger.warn("No applications found, which is strange since there are system apps which are shipped with Dachshund.");
	}

	return appsInitialized;
};

const initApplication = async function(applicationName) {

	try
	{
		await initApplicationInstallFolder(applicationName);
		await initApplicationNodeModules(applicationName);
	} catch (err)
	{
		logger.error(`Error while initialing application [${applicationName}]`, err);
	}

};

const initApplicationInstallFolder = async function(applicationName) {

	const applicationInstallPath = APPLICATIONS_BASE_PATH + "/" + applicationName + "/" + NAME_APPLICATION_INSTALL_FOLDER;
	const installPropertiesPath = applicationInstallPath.substr(1) + "/.properties.json";

	let installResource = await repositoryManager.resolve(applicationInstallPath);
	if (resourceTypes.RESOURCE === installResource.type)
	{
		if (installResource.properties.alreadyInstalled && !installResource.properties.installAlways)
		{
			logger.debug(`Application parts from [${applicationInstallPath}] already installed.`);
		}
		else
		{
			const relativeApplicationInstallPath = "." + applicationInstallPath;
			const relativeDachshundRoot = "./";
			logger.info(`Install application parts from [${applicationInstallPath}]`);

			await new Promise((resolve, reject) => {
				cpr(relativeApplicationInstallPath, relativeDachshundRoot, {
					deleteFirst: false, //Delete "to" before
					overwrite: true, //If the file exists, overwrite it
					confirm: false, //After the copy, stat all the copied files to make sure they are there
					filter: function(filename) {
						return filename !== installPropertiesPath && !bowerComponentsRegex.test(filename);
					}
				}, function(err) {
					if (err)
					{
						logger.error('Something went wrong while coping files', err);
						reject(err);
					}
					else
					{
						logger.debug(`Applications parts from [${applicationInstallPath}] installed`);
						installResource.properties.alreadyInstalled = true;
						installResource.saveProperties().then(resolve).catch(reject);
					}
				});
			});
		}
	}
	else
	{
		logger.debug(`The application [${applicationInstallPath}] has no application parts.`);
	}

};

const initApplicationNodeModules = async function(applicationName) {

	let applicationNodeModulesPath = process.cwd() + APPLICATIONS_BASE_PATH + "/" + applicationName + "/" + NODE_MODULES_PATH_NAME;
	// To be able to init the node modules which are directly defined in the /apps root path
	if (applicationName === undefined)
	{
		applicationNodeModulesPath = process.cwd() + APPLICATIONS_BASE_PATH + "/" + NODE_MODULES_PATH_NAME;
	}

	let nodeModulesInApplicationExists = await pathExists(applicationNodeModulesPath);
	if(nodeModulesInApplicationExists)
	{
		let nodeModuleNames = await fs.readdir(applicationNodeModulesPath);

		return await asyncUtils.forEachParallel(nodeModuleNames, async nodeModuleName => {
			if (nodeModuleName !== ".bin")
			{
				const pathNodeModule = applicationNodeModulesPath + "/" + nodeModuleName;
				let nodeModuleStat  = await fs.stat(pathNodeModule);
				if(nodeModuleStat.isDirectory())
				{
					let nodeModuleRelativePath = pathNodeModule.substr(process.cwd().length);
					logger.trace("Initiate node module [" + nodeModuleRelativePath + "]");
					try
					{
						require(pathNodeModule)

					} catch (err)
					{
						logger.error("Error while loading module", err);
					}
				}
			}
		});
	}

};