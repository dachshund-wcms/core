'use strict';

require('string-utils');
const Q = require('q');
const repositoryManager = require('repository-manager');
const resourceTypes = require('resource-types');
const APPLICATIONS_BASE_PATH = "/apps";
const NODE_MODULES_PATH_NAME = "node_modules";
const NAME_APPLICATION_INSTALL_FOLDER = "install";
const logger = require('dachshund-logger').getLogger(__filename);
const fs = require('fs');
const appsInitializer = exports;
const cpr = require('cpr');
const bowerComponentsRegex = /\/bower_components/;
// Asynchronous recursive file copy utility - Concurrency limit

appsInitializer.init = function() {
	const deferred = Q.defer();

	repositoryManager.resolve(APPLICATIONS_BASE_PATH).then(function(applicationsBaseResource) {
		return applicationsBaseResource.getChilds();
	}).then(function(applicationNames) {
		let promisesInitializedApps = [];

		// Init the node modules which are stored in the /apps root path
		promisesInitializedApps.push(initApplicationNodeModules());

		for (let applicationName of applicationNames)
		{
			if(applicationName != NODE_MODULES_PATH_NAME)
			{
				promisesInitializedApps.push(initApplication(applicationName));
			}
		}
		if (promisesInitializedApps.length == 0)
		{
			logger.warn("No applications found, which is strange since there are system apps which are shipped with Dachshund.");
			deferred.resolve()
		}
		else
		{
			return Q.all(promisesInitializedApps);
		}
	}).then(deferred.resolve).fail(deferred.reject);

	return deferred.promise;
};

const initApplication = function(applicationName) {
	const deferred = Q.defer();

	initApplicationInstallFolder(applicationName).then(function() {
		return initApplicationNodeModules(applicationName);
	}).then(deferred.resolve).fail(function(err){
		logger.error("Error while initialing application ["+ applicationName +"]", err);
		deferred.reject(err);
	});

	return deferred.promise;
};

const initApplicationInstallFolder = function(applicationName) {
	const deferred = Q.defer();

	const applicationInstallPath = APPLICATIONS_BASE_PATH + "/" + applicationName + "/" + NAME_APPLICATION_INSTALL_FOLDER;
	const absoluteApplicationInstallPath = process.cwd() + applicationInstallPath;
	const installPropertiesPath = applicationInstallPath.substr(1) + "/.properties.json";

	repositoryManager.resolve(applicationInstallPath).then(function(installResource) {
		if (resourceTypes.RESOURCE == installResource.type)
		{
			if (installResource.properties.alreadyInstalled && !installResource.properties.installAlways)
			{
				logger.debug("Application parts from [" + applicationInstallPath + "] already installed.");
				deferred.resolve();
			}
			else
			{
				const relativeApplicationInstallPath = "." + applicationInstallPath;
				const relativeDachshundRoot = "./";
				logger.info("Install application parts from [" + applicationInstallPath + "]");

				cpr(relativeApplicationInstallPath, relativeDachshundRoot, {
					deleteFirst: false, //Delete "to" before
					overwrite: true, //If the file exists, overwrite it
					confirm: false, //After the copy, stat all the copied files to make sure they are there
					filter: function(filename){
						return filename != installPropertiesPath && !bowerComponentsRegex.test(filename);
					}
				}, function(err) {
					if(err)
					{
						logger.error("Something went wrong while copy", err);
						deferred.reject(err);
					}
					else
					{
						logger.debug("Applications parts from [" + applicationInstallPath + "] installed");
						installResource.properties.alreadyInstalled = true;
						installResource.saveProperties().then(deferred.resolve).fail(deferred.reject);
					}
				});
			}
		}
		else
		{
			logger.debug("The application ["+ applicationInstallPath +"] has no application parts.");
			deferred.resolve();
		}
	}).fail(deferred.reject);

	return deferred.promise;
};

const initApplicationNodeModules = function(applicationName) {
	const deferred = Q.defer();

	let applicationNodeModulesPath = process.cwd() + APPLICATIONS_BASE_PATH + "/" + applicationName + "/" + NODE_MODULES_PATH_NAME;
	// To be able to init the node modules which are directly defined in the /apps root path
	if(applicationName === undefined)
	{
		applicationNodeModulesPath = process.cwd() + APPLICATIONS_BASE_PATH + "/" + NODE_MODULES_PATH_NAME;
	}
	const nodeModulePaths = [];

	Q.nfcall(fs.stat, applicationNodeModulesPath).then(function(fsStat){
		return Q.nfcall(fs.readdir, applicationNodeModulesPath);
	}).then(function(nodeModuleNames){

		let nodeModulesCheckPromises = [];
		for(let nodeModuleName of nodeModuleNames)
		{
			if(nodeModuleName != ".bin")
			{
				const pathNodeModule = applicationNodeModulesPath + "/" + nodeModuleName;
				nodeModulePaths.push(pathNodeModule);
				nodeModulesCheckPromises.push(Q.nfcall(fs.stat, pathNodeModule));
			}
		}

		return Q.all(nodeModulesCheckPromises);
	}).then(function(checkedNodeModules){
		for(var i = 0; i < nodeModulePaths.length; i++)
		{
			if(checkedNodeModules[i].isDirectory())
			{
				let nodeModuleRelativePath = nodeModulePaths[i].substr(process.cwd().length);
				logger.debug("Initiate node module ["+ nodeModuleRelativePath +"]");
				try
				{
					require(nodeModulePaths[i])

				} catch (err)
				{
					logger.error("Error while loading module", err);
				}
			}
		}
		deferred.resolve();
	}).fail(function(err){
		deferred.resolve();
	});

	return deferred.promise;
};