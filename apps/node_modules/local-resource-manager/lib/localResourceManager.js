'use strict';

const assert = require('assert');
const stringUtils = require('string-utils');
const RepositoryManager = require('repository-manager');
const LocalResource = require('local-resource');
const ResourceTypes = require('resource-types');
const fs = require('fs');
const Q = require('q');

class LocalResourceManager extends RepositoryManager {

	createEmptyResource(pathInfo) {
		return Q(new LocalResource());
	}

	createResource(newResourceBasePath, newResourceName) {
		assert(stringUtils.isNotEmpty(newResourceBasePath), 'The "newResourceBasePath" is not defined or empty.');
		assert(stringUtils.isNotEmpty(newResourceName), 'The parameter "newResourceName" is not defined or empty.');

		var deferred = Q.defer();

		var newResourcePath = newResourceBasePath + "/" + newResourceName;
		logger.debug('Create new resource with path: ' + newResourcePath);

		//Create Resource directory
		if (!fs.existsSync("." + newResourcePath))
		{
			mkdirp.sync("." + newResourcePath);
		}

		//Set time of creation and persist the change
		this.resolve(newResourcePath, function(resource) {
			resource.properties.timeCreated = new Date();
			resource.saveProperties().then(function() {
				deferred.resolve(resource);
			}).fail(deferred.reject);

		}).fail(deferred.reject);
		return deferred.promise;
	}

	static determineID(resource) {
		var deferred = Q.defer();
		resource.id = resource.properties.id;
		resource.properties.id = undefined;
		deferred.resolve(resource);
		return deferred.promise;
	}

	resolve(pathInfo) {
		assert(pathInfo != undefined, 'Resource with undefined parameter "pathInfo" requested.');

		var deferred = Q.defer();
		var resource = new LocalResource();
		var resolvedResource = Q(resource);

		if (typeof(pathInfo) == "string" && fs.existsSync("." + pathInfo) && fs.statSync("." + pathInfo).isDirectory())
		{
			resource.path = pathInfo;
			resource.type = ResourceTypes.RESOURCE;
			resource.name = pathInfo.lastSubstringAfter("/");
			resource.loadProperties().then(this.determineID).then(resource.loadAuthorization.bind(resource)).then(resolvedResource).then(deferred.resolve);
		}
		else if (typeof(pathInfo) == "string" && fs.existsSync("." + pathInfo) && fs.statSync("." + pathInfo).isFile())
		{
			resource.type = ResourceTypes.FILE;
			resource.name = pathInfo.lastSubstringAfter("/");
			resource.path = pathInfo;
			resolvedResource.then(deferred.resolve);
		}
		else if (fs.existsSync("." + pathInfo.componentPath))
		{
			resource.path = pathInfo.componentPath;
			resource.type = ResourceTypes.RESOURCE;
			resource.name = pathInfo.componentPath.lastSubstringAfter("/");
			resource.loadProperties().then(this.determineID).then(resource.loadAuthorization.bind(resource)).then(resolvedResource).then(deferred.resolve);
		}
		else if (fs.existsSync("." + pathInfo.completePath))
		{
			resource.type = ResourceTypes.FILE;
			resource.name = pathInfo.completePath.lastSubstringAfter("/");
			resource.path = pathInfo.completePath;
			resolvedResource.then(deferred.resolve);
		}
		else
		{
			resolvedResource.then(deferred.resolve);
		}

		return deferred.promise;
	}
}

module.exports = LocalResourceManager;