/**
 * This module enhances the promise library 'Q' with further functionality.
 * @module q-utils
 *
 * @example
 * const Q = require('q');
 * require('q-utils'); //no need to assign a variable since the additional methods are available through the 'Q' variable
 */
const Q = require('q');

/**
 * This method iterates over an array of value elements and executes the given function on each element of the array.
 * This method is used, when the order in which the elements get processed matters. The method ensures that Q-promise
 * waits for each element to be processed before it continues with the next one. The downside is that this util isn't
 * that it isn't as effective as other methods like _Q.all_.
 * @param {Object[]} dataArray - The data array which will be processed sequentially
 * @param {Function} functionToBeApplied - The function which will be called for each array element. The first parameter contains the array element and the second one the index of the element. The method has to return a promise.
 * @returns {promise} which resolves when the last element of the array is processed
 *
 * @example
 * const Q = require('q');
 * require('q-utils');
 *
 * let someChars = ['a', 'b', 'c', 'd', 'e'];
 * let logData = function(element, index) {
 *	const deferred = Q.defer();
 *	console.log(element + ' at position ' + index);
 *	deferred.resolve();
 *	return deferred.promise;
 * }
 *
 * Q.sequenceArray(someChars, logData).then(function(){
 * 	console.log('finished sequencing');
 * });
 *
 * // The output will be:
 * a at position 1
 * b at position 2
 * c at position 3
 * d at position 4
 * e at position 5
 * finished sequencing
 *
 */
function sequenceArray(dataArray, functionToBeApplied) {

	let emptyPromise = Q();
	return dataArray.reduce(function(lastPromise, arrayElement, index) {
		return lastPromise.then(function() {
			return functionToBeApplied(arrayElement, index);
		});
	}, emptyPromise);

}

Q.sequenceArray = sequenceArray;