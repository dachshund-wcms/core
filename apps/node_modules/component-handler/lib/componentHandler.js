/** @module component-handler/componentHandler */
'use strict';

const Q = require('q');
const componentHandler = exports;
const logger = require('dachshund-logger').getLogger(__filename);

const prepareScriptHandler = require('./prepareScriptHandler.js');

/**
 * Processes the component by looking up the script which is matches to the request and to execute the script
 * @param component {Component} The component to be handled with the enclosed request information
 * @returns {promise} resolved when a script could be resolved and executed
 * @alias module:component-handler/componentHandler.handle
 */
componentHandler.handle = function(component) {
	let deferred = Q.defer();

	prepareScriptHandler.resolveAndHandle(component).then(function() {
		// Lookup script based on the component
		return componentHandler.getScriptToHandle(component);
	}).then(function(scriptPath) {
		logger.trace("Script [" + scriptPath + "] found for component [" + component.componentResource.path + "]" + getPathinfoString(component));
		component.executeScript(scriptPath).then(deferred.resolve).fail(deferred.reject);
	}).fail(function() {
		// Was the first attempt not successful, it will be retried with the component resource name as prefix
		componentHandler.getScriptToHandle(component, component.componentResource.name).then(function(scriptPath) {
			logger.trace("Script [" + scriptPath + "] found for component [" + component.componentResource.path + "] with name [" + component.componentResource.name + "]" + getPathinfoString(component));
			component.executeScript(scriptPath).then(deferred.resolve).fail(deferred.reject);
		}).fail(function() {
			// Were both attempts to lookup a script not successful, a third lookup is execute to
			// lookup a script which is called as the comp
			component.getDefaultScript().then(function(scriptPath) {
				logger.trace("Default script [" + scriptPath + "] found for component [" + component.componentResource.path + "]" + getPathinfoString(component));
				component.executeScript(scriptPath).then(deferred.resolve).fail(deferred.reject);
			}).fail(function() {
				deferred.reject(new Error("No matching script can be found in this component [" + component.componentResource.path + "]" + getPathinfoString(component)));
			});
		})
	});

	return deferred.promise;
};

/**
 * Lookup a matching script which is able to handle the request with the speicifed selector and extension in the {@link RequestPathInfo}
 * @param {Component} component - with the enclosed request information
 * @param {string} prefix - will be set in front of the script file name to resolve a possible match
 * @returns {promise} which resolves with the scriptPath {string}
 * @alias module:component-handler/componentHandler.getScriptToHandle
 */
componentHandler.getScriptToHandle = function(component, prefix) {
	let deferred = Q.defer();

	if (prefix == undefined)
	{
		prefix = "";
	}
	else
	{
		prefix = prefix + ".";
	}

	resolveScriptByMethodSelectorAndExtension(component, prefix).then(function(scriptPath) {
		deferred.resolve(scriptPath);
	}).fail(function() {
		return resolveScriptBySelector(component, prefix);
	}).then(function(scriptPath) {
		deferred.resolve(scriptPath);
	}).fail(function() {
		resolverScriptByExtension(component, prefix).then(function(scriptPath) {
			deferred.resolve(scriptPath);
		}).fail(function() {
			resolveScriptByMethodName(component, prefix).then(function(scriptPath) {
				deferred.resolve(scriptPath);
			}).fail(function() {
				deferred.reject(new Error("No script found for component: " + component.componentResource.path));
			});
		});
	});

	return deferred.promise;
};

const resolveScriptByMethodName = function(component, prefix) {
	let deferred = Q.defer();
	let scriptName = prefix + component.pathInfo.method;
	component.resolveScript(scriptName).then(deferred.resolve).fail(deferred.reject);
	return deferred.promise;
};

const resolverScriptByExtension = function(component, prefix) {
	let deferred = Q.defer();
	if (component.pathInfo.method == "GET" && component.pathInfo.selector != null)
	{
		let scriptName = prefix + component.pathInfo.extension;
		component.resolveScript(scriptName).then(deferred.resolve).fail(deferred.reject);
	}
	else
	{
		deferred.reject();
	}
	return deferred.promise;
};

const resolveScriptBySelector = function(component, prefix) {
	let deferred = Q.defer();
	if (component.pathInfo.method == "GET" && component.pathInfo.selector != null)
	{
		let scriptName = prefix + component.pathInfo.selector;
		component.resolveScript(scriptName).then(deferred.resolve).fail(deferred.reject);
	}
	else
	{
		deferred.reject();
	}
	return deferred.promise;
};

const resolveScriptByMethodSelectorAndExtension = function(component, prefix) {
	let deferred = Q.defer();
	let scriptName = "";

	if (component.pathInfo.method == "GET" && component.pathInfo.selector == null)
	{
		scriptName = prefix + component.pathInfo.extension;
	}
	else if (component.pathInfo.method == "GET" && component.pathInfo.selector != null)
	{
		scriptName = prefix + component.pathInfo.selector + "." + component.pathInfo.extension;
	}
	else if (component.pathInfo.selector == null)
	{
		scriptName = prefix + component.pathInfo.method + "." + component.pathInfo.extension;
	}
	else if (component.pathInfo.selector != null)
	{
		scriptName = prefix + component.pathInfo.method + "." + component.pathInfo.selector + "." + component.pathInfo.extension;
	}

	component.resolveScript(scriptName).then(deferred.resolve).fail(deferred.reject);
	return deferred.promise;
};

const getPathinfoString = function(component) {
	return " request method [" + component.pathInfo.method + "] selector [" + component.pathInfo.selector + "] extension [" + component.pathInfo.extension + "]";
};
