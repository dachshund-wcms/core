/** @module component-handler/dispatcher */
'use strict';

const Q = require('q');
const logger = require('dachshund-logger').getLogger(__filename);
const repositoryManager = require('repository-manager');
const componentLoader = require("./componentLoader.js");
const componentHandler = require("./componentHandler.js");
const resourceTypes = require("resource-types");
const mime = require("mime");

const dispatcher = exports;

/**
 * Called when component is processed and the result shall be send within the response
 * @param {ServerResponse} res - Response to which the data shall be send
 * @param {RequestPathInfo} pathInfo - To resolve the mime type from the requested file extension
 * @param {string} data - processed data to be passed back in the HTTP response
 * @alias module:component-handler/dispatcher.complete
 */
dispatcher.complete = function(res, pathInfo, data) {
	let mimetype = mime.lookup(pathInfo.extension);

	res.writeHead(200, {"Content-Type": mimetype + "; charset=utf-8"});
	res.write(data);
	res.end();
};

/**
 * Called when something went wrong while processing the component. It ends the request properly and provides
 * further information why the request failed
 * @param {ServerResponse} res - Response to which the data shall be send
 * @param {string|Error} data - error message which is send back in the HTTP response
 * @alias module:component-handler/dispatcher.fail
 */
dispatcher.fail = function(res, data) {
	let responseMessage = data;
	let logMessage = data;
	if (data instanceof Error)
	{
		responseMessage = data.message;
		logMessage = data.message + '\n' + data.stack;
	}
	else if (!(data instanceof String))
	{
		responseMessage = JSON.stringify(data, null, 4);
		logMessage = responseMessage;
	}
	logger.error(logMessage);
	res.writeHead(500, {"Content-Type": "text/plain; charset=utf-8"});
	res.write(responseMessage);
	res.end();
};

/**
 * Dispatched the HTTP request
 * @param {ClientRequest} req
 * @param {ServerResponse} res
 * @param {RequestPathInfo} pathInfo
 * @param {Resource} contentResource
 * @alias module:component-handler/dispatcher.dispatchRequest
 */
dispatcher.dispatchRequest = function(req, res, pathInfo, contentResource) {
	let deferred = Q.defer();
	deferred.promise.then(function(data) {
		if (data != undefined)
		{
			dispatcher.complete(res, pathInfo, data);
		}
	}).fail(function(data) {
		if (data != undefined)
		{
			dispatcher.fail(res, data);
		}
	});

	if (contentResource.properties.componentPath == undefined)
	{
		deferred.reject(new Error("Resource path is not set for resource '" + contentResource.path + "'"));
	}

	let componentResourcePath = contentResource.properties.componentPath;

	if (contentResource.properties.componentPath == "SELF")
	{
		componentResourcePath = contentResource.path;
	}

	repositoryManager.resolve(componentResourcePath).then(function(componentResource) {
		if(resourceTypes.NOT_FOUND == componentResource.type)
		{
			throw new Error('The component resource ['+ componentResourcePath +'] couldn\'t be found.');
		}

		return componentLoader.load(req, res, pathInfo, contentResource, componentResource);
	}).then(function(component) {
		componentHandler.handle(component).then(deferred.resolve).fail(deferred.reject);
	}).fail(deferred.reject);
};

dispatcher.dispatchComponent = function(resourcePath, componentPath, parentComponent, selector) {
	let deferred = Q.defer();
	let contentResource = null;
	let contentResourceCreated = false;
	let resourcePropertiesUndefined = false;

	const resourcePostProcess = function(subComponentResource) {
		var deferred = Q.defer();
		if (contentResourceCreated || resourcePropertiesUndefined)
		{
			if (contentResource.properties.timeCreated == undefined)
			{
				contentResource.properties.timeCreated = new Date();
			}
			contentResource.properties.componentPath = subComponentResource.path;
			contentResource.saveProperties().then(deferred.resolve).fail(deferred.reject);
		}
		else
		{
			deferred.resolve();
		}
		return deferred.promise;
	};

	const loadComponent = function() {
		if (componentPath == undefined && contentResource.properties.componentPath != undefined)
		{
			componentPath = contentResource.properties.componentPath;
			repositoryManager.resolve(componentPath).then(function(subComponentResource) {
				handleComponent(subComponentResource);
			}).fail(function(err) {
				logger.error("Error while resolving resource '" + componentPath + "' because of: " + err.toString());
			});
		}
		else if (componentPath != undefined && componentPath.startsWith("./") && contentResource.properties.componentPath != undefined)
		{
			componentPath = contentResource.properties.componentPath + "/" + componentPath.substringAfter("./");
			repositoryManager.resolve(componentPath).then(function(subComponentResource) {
				handleComponent(subComponentResource);
			}).fail(function(err) {
				logger.error("Error while resolving resource '" + componentPath + "' because of: " + err.toString());
			});
		}
		else
		{
			repositoryManager.resolve(componentPath).then(function(subComponentResource) {
				handleComponent(subComponentResource);
			}).fail(function(err) {
				logger.error("Error while resolving resource '" + componentPath + "' because of: " + err.toString());
			});
		}
	};

	const handleComponent = function(subComponentResource) {
		resourcePostProcess(subComponentResource).then(function() {
			if (subComponentResource.type == resourceTypes.NOT_FOUND)
			{
				logger.error("No component resource could be resolved at '" + componentPath + "'");
			}

			let pathInfo = parentComponent.pathInfo;
			if (selector != undefined)
			{
				pathInfo = pathInfo.clone();
				pathInfo.selector = selector;
			}

			componentLoader.load(parentComponent.req, parentComponent.res, pathInfo, contentResource, subComponentResource).then(function(subComponent) {
				componentHandler.handle(subComponent).then(deferred.resolve).fail(deferred.reject);
			});
		}).fail(function(err){
			logger.error("Error while executing post process of component because of: " + err.toString());
		});
	};

	if (resourcePath == "" || resourcePath == "." || resourcePath == "./")
	{
		contentResource = parentComponent.resource;
		loadComponent();
	}
	else
	{
		if (resourcePath.startsWith("./"))
		{
			resourcePath = parentComponent.resource.path + "/" + resourcePath.substr(2);
		}
		else if (!resourcePath.startsWith("/") && !resourcePath.startsWith("./"))
		{
			resourcePath = parentComponent.resource.path + "/" + resourcePath;
		}

		repositoryManager.resolve(resourcePath).then(function(resource) {
			if (resourceTypes.NOT_FOUND == resource.type)
			{
				repositoryManager.createResource(resourcePath, function(resource) {
					contentResource = resource;
					contentResourceCreated = true;
					loadComponent();
				});
			}
			else
			{
				contentResource = resource;
				resourcePropertiesUndefined = (contentResource.properties.timeLastChange == undefined);
				loadComponent();
			}
		}).fail(function(err) {
			logger.error("Error while resolving resource '" + resourcePath + "' because of: " + err.toString());
		});
	}

	return deferred.promise;
};
