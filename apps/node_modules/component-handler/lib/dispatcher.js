/** @module component-handler/dispatcher */
'use strict';

const logger = require('dachshund-logger').getLogger(__filename);
const repositoryManager = require('repository-manager');
const componentLoader = require("./componentLoader.js");
const componentHandler = require("./componentHandler.js");
const resourceTypes = require("resource-types");
const mime = require("mime");

const dispatcher = exports;

/**
 * Called when component is processed and the result shall be send within the response
 * @param {ServerResponse} res - Response to which the data shall be send
 * @param {RequestPathInfo} pathInfo - To resolve the mime type from the requested file extension
 * @param {string} data - processed data to be passed back in the HTTP response
 * @alias module:component-handler/dispatcher.complete
 */
dispatcher.complete = function(res, pathInfo, data) {
	let mimetype = mime.lookup(pathInfo.extension);

	res.writeHead(200, {"Content-Type": mimetype + "; charset=utf-8"});
	res.write(data);
	res.end();
};

/**
 * Called when something went wrong while processing the component. It ends the request properly and provides
 * further information why the request failed
 * @param {ServerResponse} res - Response to which the data shall be send
 * @param {string|Error} data - error message which is send back in the HTTP response
 * @alias module:component-handler/dispatcher.fail
 */
dispatcher.fail = function(res, data) {
	let responseMessage = data;
	let logMessage = data;
	if (data instanceof Error)
	{
		responseMessage = data.message;
		logMessage = data.message + '\n' + data.stack;
	}
	else if (!(data instanceof String))
	{
		responseMessage = JSON.stringify(data, null, 4);
		logMessage = responseMessage;
	}
	logger.error(logMessage);
	res.writeHead(500, {"Content-Type": "text/plain; charset=utf-8"});
	res.write(responseMessage);
	res.end();
};

let resolveCompontent =

	/**
	 * Dispatched the HTTP request
	 * @param {ClientRequest} req
	 * @param {ServerResponse} res
	 * @param {RequestPathInfo} pathInfo
	 * @param {Resource} contentResource
	 * @alias module:component-handler/dispatcher.dispatchRequest
	 */
	dispatcher.dispatchRequest = async function(req, res, pathInfo, contentResource) {
		try
		{

			if (contentResource.properties.componentPath === undefined)
			{
				throw new Error(`Resource path is not set for resource [${contentResource.path}]`);
			}

			let componentResourcePath = contentResource.properties.componentPath;

			if (contentResource.properties.componentPath === 'SELF')
			{
				componentResourcePath = contentResource.path;
			}

			let componentResource = await repositoryManager.resolve(componentResourcePath);

			if (resourceTypes.NOT_FOUND === componentResource.type)
			{
				throw new Error('The component resource [' + componentResourcePath + '] couldn\'t be found.');
			}

			let component = await componentLoader.load(req, res, pathInfo, contentResource, componentResource);
			let data = await componentHandler.handle(component);
			if(data !== undefined)
			{
				dispatcher.complete(res, pathInfo, data);
			}

		} catch (err)
		{
			dispatcher.fail(res, err);
		}
	};

dispatcher.dispatchComponent = async function(resourcePath, componentPath, parentComponent, selector) {
	let contentResource = null;
	let contentResourceCreated = false;
	let resourcePropertiesUndefined = false;

	const resourcePostProcess = async function(subComponentResource) {
		if (contentResourceCreated || resourcePropertiesUndefined)
		{
			if (contentResource.properties.timeCreated === undefined)
			{
				contentResource.properties.timeCreated = new Date();
			}
			contentResource.properties.componentPath = subComponentResource.path;
			await contentResource.saveProperties();
		}
	};

	const loadComponent = async function() {
		if (componentPath === undefined && contentResource.properties.componentPath !== undefined)
		{
			let componentPath = contentResource.properties.componentPath;
			let subComponentResource = await repositoryManager.resolve(componentPath);
			return await handleComponent(subComponentResource);
		}
		else if (componentPath !== undefined && componentPath.startsWith("./") && contentResource.properties.componentPath !== undefined)
		{
			componentPath = contentResource.properties.componentPath + "/" + componentPath.substringAfter("./");
			let subComponentResource = await repositoryManager.resolve(componentPath);
			return await handleComponent(subComponentResource);
		}
		else
		{
			let subComponentResource = await repositoryManager.resolve(componentPath);
			return await handleComponent(subComponentResource);
		}
	};

	const handleComponent = async function(subComponentResource) {
		await resourcePostProcess(subComponentResource);
		if (subComponentResource.type === resourceTypes.NOT_FOUND)
		{
			logger.error("No component resource could be resolved at '" + componentPath + "'");
		}

		let pathInfo = parentComponent.pathInfo;
		if (selector !== undefined)
		{
			pathInfo = pathInfo.clone();
			pathInfo.selector = selector;
		}

		let subComponent = await componentLoader.load(parentComponent.req, parentComponent.res, pathInfo, contentResource, subComponentResource);
		return await componentHandler.handle(subComponent);
	};

	if (resourcePath === "" || resourcePath === "." || resourcePath === "./")
	{
		contentResource = parentComponent.resource;
		return await loadComponent();
	}
	else
	{
		if (resourcePath.startsWith("./"))
		{
			resourcePath = parentComponent.resource.path + "/" + resourcePath.substr(2);
		}
		else if (!resourcePath.startsWith("/") && !resourcePath.startsWith("./"))
		{
			resourcePath = parentComponent.resource.path + "/" + resourcePath;
		}


		let resource = await repositoryManager.resolve(resourcePath);
		if (resourceTypes.NOT_FOUND === resource.type)
		{
			let resourceBasePath = resourcePath.lastSubstringBefore("/");
			let newResourceName = resourcePath.lastSubstringAfter("/");
			contentResource = await repositoryManager.createResource(resourceBasePath, newResourceName);
			contentResourceCreated = true;
			return await loadComponent();
		}
		else
		{
			contentResource = resource;
			resourcePropertiesUndefined = (contentResource.properties.timeLastChange === undefined);
			return await loadComponent();
		}
	}
};
