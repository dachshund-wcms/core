'use strict';

const Q = require('q');
const repositoryManager = require('repository-manager');
const repositorySecurityManager = require('repository-security-manager');
const resourceTypes = require('resource-types');
const logger = require('dachshund-logger').getLogger(__filename);

const secureResourceManager = exports;

secureResourceManager.secureResource = function(resource, userSession) {
	let deferred = Q.defer();

	if (resource.type == resourceTypes.RESOURCE)
	{
		resource._user = userSession;

		resource.isAuthorized = function(type) {
			return repositorySecurityManager.userIsAuthorized(this._authorizationList, this._user, type);
		};

		repositorySecurityManager.getAuthorizationList(resource).spread(function(allowList, denyList) {

			resource._authorizationList = {
				allow: allowList,
				deny: denyList
			};

			if (!resource.isAuthorized("read"))
			{
				logger.warn("'" + userSession.user.path + "' has no read access to '" + resource.path + "'");
				repositoryManager.createEmptyResource(resource.path).then(deferred.resolve).fail(deferred.reject);
			}
			else
			{
				resource.getChildResources = secureResourceManager_getChildResources;

				if (!resource.isAuthorized("modify"))
				{
					resource.saveProperties = function() {
						let deferred = Q.defer();
						let message = "User is not authorized to modify properties of: " + this.path;
						logger.error(message);
						deferred.reject(new Error(message));
						return deferred;
					}
				}
				else
				{
					resource._saveProperties = resource.saveProperties;
					resource.saveProperties = function() {
						resource.properties.modifiedBy = this._user.user.name;
						return this._saveProperties();
					};
				}

				if (!resource.isAuthorized("modAuth"))
				{
					resource.saveAuthorization = function() {
						let deferred = Q.defer();
						let message = "User is not authorized to modify the resource authorization of: " + this.path;
						let error = new Error(message);
						logger.error(message);
						deferred.reject(error);
						return deferred;
					}
				}

				deferred.resolve(resource);
			}
		}).fail(deferred.reject);
	}
	else
	{
		deferred.resolve(resource);
	}

	return deferred.promise;
};

const secureResourceManager_getChildResources = function() {
	let deferred = Q.defer();
	let self = this;
	this.getChilds().then(function(childNames) {

		if (childNames.length == 0)
		{
			deferred.resolve([]);
		}

		let securedChildResourcePromises = [];
		childNames.forEach(function(childName) {
			let childResourcePath = self.path + "/" + childName;
			let deferred = Q.defer();
			securedChildResourcePromises.push(deferred.promise);
			repositoryManager.resolve(childResourcePath).then(function(childResource) {
				return secureResourceManager.secureResource(childResource, self._user);
			}).then(deferred.resolve).fail(deferred.reject);
		});
		Q.all(securedChildResourcePromises).then(function(securedChildResources) {
			deferred.resolve(securedChildResources);
		}).fail(deferred.reject);
	});
	return deferred.promise;
};